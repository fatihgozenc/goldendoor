{"ast":null,"code":"import _Array$from from \"@babel/runtime-corejs2/core-js/array/from\";\nimport React from \"react\";\nvar __jsx = React.createElement;\nimport LoopingItem from './LoopingItem';\n\nconst openCarousel = e => {\n  const imgID = e.currentTarget.classList[1];\n  const mainContainer = e.currentTarget.parentElement.parentElement.parentElement;\n  mainContainer.lastElementChild.classList.add('show');\n  setTimeout(() => {\n    mainContainer.lastElementChild.classList.add('gallerySliderOpen');\n    setTimeout(() => {\n      mainContainer.lastElementChild.lastElementChild.classList.add('gallerySliderBlockOpen');\n    }, 750);\n  }, 10);\n  const elementInCarousel = mainContainer.lastElementChild.getElementsByClassName(`img-${imgID}`);\n  const elementInCarouselIndex = elementInCarousel[0].getAttribute('slideindex');\n  mainContainer.lastElementChild.lastElementChild.lastElementChild.lastElementChild.children[elementInCarouselIndex].click();\n}; //FUNCTION FOR CLONING THE CHILDREN OF A DOM NODE.\n\n\nconst cloneChildren = el => {\n  let items = _Array$from(el.childNodes);\n\n  items.forEach(function (item) {\n    var clone = item.cloneNode(true);\n    clone.addEventListener('click', openCarousel);\n    el.appendChild(clone);\n  });\n};\n\nconst LoopingRow = props => {\n  //INITIAL DOM WITH IS 0 BECAUSE IMAGES WILL CHANGE SIZE DEPENDING ON SCREEN SIZE\n  const [width, setWidth] = React.useState(0);\n  const [canStart, setCanStart] = React.useState(false);\n  const [transition] = React.useState(150); //AS A CALLBACK FUNCTION LOADED ITEM SENDS ITS WIDTH TO ROW ELEMENTS' STATE\n  //AND WITH THE HELP OF REACT.MEMO zROW ELEMENT DOESN'T RE-RENDER\n\n  const measure = React.useCallback(n => {\n    setWidth(c => Math.round((c + n) * 100) / 100);\n    setCanStart(true);\n  }, [setWidth]);\n  const galleryRow = React.useRef(); //THIS CUSTOM HOOK IS FOR TESTING RENDERING COUNT\n  // useCountRenders();\n  // React.useEffect(() => {\n  // \tconsole.log(galleryRow.current.parentElement.querySelectorAll('.looping_gallery_item'))\n  // }, [])\n\n  React.useEffect(() => {\n    //COMPONENTDIDMOUNT\n    let row = galleryRow.current; // console.log(`Rows have mounted.`)\n    //IF ROW IS ABLE START TO ANIMATE AND ITS' WIDTH IS CALCULATED,\n    //THEN CLONE THE CHILDREN\n\n    if (canStart && width > 0) {\n      cloneChildren(row);\n      row.style.transitionDuration = `${transition}s`;\n      row.style.transform = `translateX(-${width}px)`;\n    } //COMPONENTWILLUNMOUNT\n\n\n    return () => {\n      if (canStart) {\n        localStorage.setItem('shouldBeCloned', 'false'); // console.log('Rows have unmounted')\n\n        row.style.transitionDuration = `0s`;\n        row.style.transform = `translateX(0px)`;\n      } else {\n        return null;\n      }\n    };\n  }, [canStart, transition, width]);\n\n  const loopTheGallery = e => {\n    //DETECTING IF TRANSITIONEND FIRES ON ROW ELEMENT ONLY\n    if (e.target === galleryRow.current) {\n      //RESETS CSS\n      galleryRow.current.style.transitionDuration = `0s`;\n      galleryRow.current.style.transform = `translateX(0px)`; //RE-INITIALIZING IT\n\n      setTimeout(() => {\n        galleryRow.current.style.transitionDuration = `${transition}s`;\n        galleryRow.current.style.transform = `translateX(-${width}px)`;\n      }, 1);\n    }\n  };\n\n  return __jsx(\"div\", {\n    className: \"looping_gallery_row\",\n    onTransitionEnd: loopTheGallery,\n    ref: galleryRow\n  }, props.data.map((item, key) => __jsx(LoopingItem, {\n    order: key + 1,\n    rowNumber: props.rowNumber,\n    id: item.bild.id,\n    windowWidth: props.windowWidth,\n    windowHeight: props.windowHeight,\n    measure: measure,\n    key: item.bild.id,\n    width: item.bild.sizes[\"medium_large-width\"],\n    height: item.bild.sizes[\"medium_large-height\"],\n    type: item.info.veranstaltungsart,\n    alt: item.info.titel,\n    highResUrl: item.bild.sizes.medium\n  })));\n};\n\nexport default LoopingRow;","map":null,"metadata":{},"sourceType":"module"}