{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Icon from '../Icon';\nimport parse from 'html-react-parser';\nimport Obfuscate from 'react-obfuscate';\nimport './style.scss';\nconst IMG_WIDTH = 300;\nconst IMG_HEIGHT = 300;\nconst parentPad = 0;\nconst VISIBLEIMAGES = 3;\nconst DURATION = 750;\nexport default function (props) {\n  const {\n    imgList = [],\n    img_width = IMG_WIDTH,\n    img_height = IMG_HEIGHT,\n    visibleImages = VISIBLEIMAGES,\n    duration = DURATION,\n    autoNext = false,\n    timeForNext = 3000\n  } = props;\n  const [currFirstImg, setCurrFirstImg] = React.useState(0);\n  const [actualFirst, setActualFirst] = React.useState('');\n  const [visibleItemsProps, setVisibleItemsProps] = React.useState({\n    order: [],\n    styles: {}\n  });\n  const currMiddleImgRef = React.useRef(0);\n  const intervalRef = React.useRef(0);\n  const imgDifference = React.useRef(1);\n  const durationRef = React.useRef(duration);\n  const wrapper = React.useRef();\n  const parentHeight = img_height + 2 * parentPad;\n  const parentWidth = img_width * 3;\n  const elementsInLeft = Math.ceil(visibleImages / 2);\n  const elementsInRight = visibleImages - elementsInLeft;\n\n  const changeCenter = ({\n    event,\n    index\n  }) => {\n    const currFirstImgIndex = visibleItemsProps.order.indexOf(currFirstImg);\n    const prevIndex = visibleItemsProps.order[currFirstImgIndex - 1];\n    const nextIndex = visibleItemsProps.order[currFirstImgIndex + 1];\n\n    if (index !== currFirstImg) {\n      if (index === prevIndex || index === nextIndex) {\n        setCurrFirstImg(index);\n      } else {\n        const val = currFirstImgIndex - visibleItemsProps.order.indexOf(index);\n        imgDifference.current = Math.abs(val);\n        setActualFirst(index);\n        cycleToNextImage(index);\n      }\n    } else {\n      null;\n    }\n  };\n\n  const cycleToNextImage = actual => {\n    if (visibleItemsProps.order.indexOf(currMiddleImgRef.current) > visibleItemsProps.order.indexOf(actual)) {\n      // Right side image click\n      currMiddleImgRef.current = currMiddleImgRef.current - 1 > -1 ? currMiddleImgRef.current - 1 : imgList.length - 1; // Right side image click\n\n      setCurrFirstImg(currMiddleImgRef.current);\n    } else {\n      // Left side image click\n      currMiddleImgRef.current = currMiddleImgRef.current + 1 < imgList.length ? currMiddleImgRef.current + 1 : 0; // Conditions to handle cycle\n\n      setCurrFirstImg(currMiddleImgRef.current);\n    }\n  };\n\n  const gapBetween = props.name === 'team' ? 4.4 : 3.4;\n\n  const constructVisibleItemsProps = () => {\n    const visibleItemsProps = {}; // To store config for items that are visibile in the carousel\n\n    visibleItemsProps.order = [];\n    let curr_center = currFirstImg; // Storing the Current Middle element in focus\n\n    let timesToIterate = 0; // To iterate through all visible number of images.\n\n    let zIndex = -elementsInRight; // We start from left to right and Zindex has to keep on increasing till middle then has to reduce.\n\n    let xTranslate = img_width; // To move the element with respect to x axis\n\n    let zTranslate = 0; // To reduce image size for images apart from center\n\n    let opacity = 1; // ARALIKLAR BURADA = 4\n\n    const division = img_width * (gapBetween / elementsInLeft); // Specifies the length that next image has to move away from with respect to current image (1.6 times the current image)\n\n    let opacityDivider = 1 / elementsInRight; // minimum opacity should be 0.3 (1-0.7)\n\n    let rightEltCount = elementsInRight;\n    let leftEltCount = elementsInLeft; // including middle element\n\n    let curr_center_copy = curr_center;\n\n    while (timesToIterate < visibleImages) {\n      const styles = {};\n      let currImgIndex;\n      let currImgIndexOnRight = true; // Tells if in this iteration the currently iterated image lies left to the middle image or not\n      // To set properties for elements in right side\n\n      if (timesToIterate < elementsInRight) {\n        const nextIndex = curr_center - rightEltCount;\n        currImgIndex = nextIndex > -1 ? nextIndex : imgList.length - Math.abs(nextIndex); // Gives the rightmost elemnt in first iteration and then the subsequent elements down the iteration\n\n        opacity = 1 - opacityDivider * rightEltCount; // To assign lowest opacity to last element and increaing it till we come to middle\n\n        zTranslate = -division * rightEltCount; // To increase the size of the images subsequently from last to middle\n\n        xTranslate = img_width - division * rightEltCount; // X coordinate position\n\n        rightEltCount--;\n      } else {\n        // To set properties for elements in center and to left of it. All props behaves similar to right\n        currImgIndexOnRight = false;\n        currImgIndex = curr_center_copy;\n\n        if (curr_center_copy + 1 >= imgList.length) {\n          // to maintain cyclic carousel\n          curr_center_copy = 0;\n        } else {\n          curr_center_copy++;\n        }\n\n        opacity = 1 - opacityDivider * Math.abs(leftEltCount - (timesToIterate + 1));\n        zTranslate = -division * Math.abs(leftEltCount - (timesToIterate + 1));\n        xTranslate = img_width + division * Math.abs(leftEltCount - (timesToIterate + 1));\n      } // Assigning above calculated values to 'styles' object\n\n\n      styles.transform = 'translateX(' + xTranslate + 'px) translateZ(' + zTranslate + 'px)';\n      styles.opacity = opacity;\n      styles.zIndex = currImgIndexOnRight ? zIndex++ : zIndex--; // To reduce zIndex while going through left elements\n\n      visibleItemsProps.order.push(currImgIndex); // Push the current image number in the orders array\n\n      visibleItemsProps[currImgIndex] = {\n        styles\n      }; // pushing all previously created styles\n\n      timesToIterate++;\n    }\n\n    durationRef.current = actualFirst === '' ? duration : duration / imgDifference.current; // duration will be user given if he clicks next image or\n    // we divide the duration by number of images skipped\n\n    setVisibleItemsProps(visibleItemsProps); // setting state for visible items\n  };\n\n  React.useEffect(() => {\n    clearInterval(intervalRef.current);\n\n    if (actualFirst !== '') {\n      intervalRef.current = setInterval(() => {\n        if (actualFirst !== '' && actualFirst !== currMiddleImgRef.current) {\n          // If the currentimage in middle is not actually clicked image then gotoNext image\n          cycleToNextImage(actualFirst);\n        } else if (actualFirst !== '' && actualFirst === currMiddleImgRef.current) {\n          setActualFirst('');\n          imgDifference.current = 1;\n          clearInterval(intervalRef.current); // If actual clicked and middle image are same we are all set to clear intervals, as they are unnecessary now\n        }\n      }, durationRef.current - 100); // Introduced an advance of 100ms to begin bringing nextimage\n      // to middle before the previous one settles down else it looks jerky\n    }\n  }, [actualFirst]);\n  React.useEffect(() => {\n    constructVisibleItemsProps(); // This constructs all css properties to the elements in visibility\n\n    currMiddleImgRef.current = currFirstImg; // Need to set it here as well so while accessing inside interval it will have the latest value\n  }, [currFirstImg]);\n  React.useEffect(() => {\n    if (autoNext) {\n      setInterval(() => {\n        const nextImg = currMiddleImgRef.current + 1 < imgList.length ? currMiddleImgRef.current + 1 : 0;\n        setCurrFirstImg(nextImg);\n      }, timeForNext);\n    }\n  }, []);\n  const [middleImageKey, setMiddleImageKey] = React.useState(0);\n\n  const loadCarousel = () => {\n    return __jsx(\"div\", {\n      className: `carousel__3D carousel__3D--${props.name}`\n    }, __jsx(\"ul\", {\n      ref: wrapper,\n      className: \"carousel__wrapper\",\n      style: {\n        height: parentHeight + 'px',\n        width: parentWidth + 'px',\n        padding: parentPad + 'px',\n        perspective: '500px'\n      }\n    }, imgList.map((image, index) => {\n      const displayNone = visibleItemsProps.order.indexOf(index) === -1; // To not to show images that are out of visibility scope\n\n      const styles = visibleItemsProps[index] ? visibleItemsProps[index].styles : {};\n      return __jsx(\"li\", {\n        key: index,\n        className: 'carousel__item ' + (displayNone ? 'd-none' : ''),\n        style: _objectSpread({}, styles, {\n          position: 'absolute',\n          transition: `all ${durationRef.current}ms ease `\n        }),\n        onClick: e => {\n          changeCenter({\n            e,\n            index\n          });\n          setMiddleImageKey(index);\n        }\n      }, __jsx(\"img\", {\n        src: image,\n        alt: 'img',\n        width: img_width,\n        height: img_height\n      }));\n    })), __jsx(\"div\", {\n      className: `carousel__infos carousel__infos--${props.name}`\n    }, props.name === \"team\" ? props.data.map((item, key) => key === middleImageKey && __jsx(\"div\", {\n      key: key,\n      className: \"infos__item\"\n    }, __jsx(\"h3\", null, item.mitarbeiter_name), __jsx(\"h4\", null, item.mitarbeiter_titel), __jsx(Obfuscate, {\n      email: item.mitarbeiter_email\n    }), __jsx(Obfuscate, {\n      tel: item.mitarbeiter_telefon\n    }))) : props.data.map((item, key) => key === middleImageKey && __jsx(\"div\", {\n      key: key,\n      className: \"infos__item infos__item--downloads\"\n    }, __jsx(\"h4\", null, item.name), __jsx(\"a\", {\n      href: item.link,\n      target: \"_blank\",\n      className: \"singleloc__button\"\n    }, __jsx(Icon, {\n      type: \"factsheet\",\n      name: \"DOWNLOAD\"\n    }))))), props.name === \"downloads\" && __jsx(\"div\", {\n      className: \"download__section--factsheet\"\n    }, __jsx(\"h2\", null, \"Factsheets\"), parse(props.content.Inhalt)));\n  };\n\n  return __jsx(React.Fragment, null, loadCarousel());\n}","map":null,"metadata":{},"sourceType":"module"}