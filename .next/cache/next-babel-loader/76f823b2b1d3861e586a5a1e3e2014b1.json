{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Icon from '../Icon';\nimport parse from 'html-react-parser';\nimport Obfuscate from 'react-obfuscate';\nimport './style.scss';\nvar IMG_WIDTH = 300;\nvar IMG_HEIGHT = 300;\nvar parentPad = 0;\nvar VISIBLEIMAGES = 3;\nvar DURATION = 750;\nexport default function (props) {\n  var _props$imgList = props.imgList,\n      imgList = _props$imgList === void 0 ? [] : _props$imgList,\n      _props$img_width = props.img_width,\n      img_width = _props$img_width === void 0 ? IMG_WIDTH : _props$img_width,\n      _props$img_height = props.img_height,\n      img_height = _props$img_height === void 0 ? IMG_HEIGHT : _props$img_height,\n      _props$visibleImages = props.visibleImages,\n      visibleImages = _props$visibleImages === void 0 ? VISIBLEIMAGES : _props$visibleImages,\n      _props$duration = props.duration,\n      duration = _props$duration === void 0 ? DURATION : _props$duration,\n      _props$autoNext = props.autoNext,\n      autoNext = _props$autoNext === void 0 ? false : _props$autoNext,\n      _props$timeForNext = props.timeForNext,\n      timeForNext = _props$timeForNext === void 0 ? 3000 : _props$timeForNext;\n\n  var _React$useState = React.useState(0),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      currFirstImg = _React$useState2[0],\n      setCurrFirstImg = _React$useState2[1];\n\n  var _React$useState3 = React.useState(''),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      actualFirst = _React$useState4[0],\n      setActualFirst = _React$useState4[1];\n\n  var _React$useState5 = React.useState({\n    order: [],\n    styles: {}\n  }),\n      _React$useState6 = _slicedToArray(_React$useState5, 2),\n      visibleItemsProps = _React$useState6[0],\n      setVisibleItemsProps = _React$useState6[1];\n\n  var currMiddleImgRef = React.useRef(0);\n  var intervalRef = React.useRef(0);\n  var imgDifference = React.useRef(1);\n  var durationRef = React.useRef(duration);\n  var wrapper = React.useRef();\n  var parentHeight = img_height + 2 * parentPad;\n  var parentWidth = img_width * 3;\n  var elementsInLeft = Math.ceil(visibleImages / 2);\n  var elementsInRight = visibleImages - elementsInLeft;\n\n  var changeCenter = function changeCenter(_ref) {\n    var event = _ref.event,\n        index = _ref.index;\n    var currFirstImgIndex = visibleItemsProps.order.indexOf(currFirstImg);\n    var prevIndex = visibleItemsProps.order[currFirstImgIndex - 1];\n    var nextIndex = visibleItemsProps.order[currFirstImgIndex + 1];\n\n    if (index !== currFirstImg) {\n      if (index === prevIndex || index === nextIndex) {\n        setCurrFirstImg(index);\n      } else {\n        var val = currFirstImgIndex - visibleItemsProps.order.indexOf(index);\n        imgDifference.current = Math.abs(val);\n        setActualFirst(index);\n        cycleToNextImage(index);\n      }\n    } else {\n      null;\n    }\n  };\n\n  var cycleToNextImage = function cycleToNextImage(actual) {\n    if (visibleItemsProps.order.indexOf(currMiddleImgRef.current) > visibleItemsProps.order.indexOf(actual)) {\n      // Right side image click\n      currMiddleImgRef.current = currMiddleImgRef.current - 1 > -1 ? currMiddleImgRef.current - 1 : imgList.length - 1; // Right side image click\n\n      setCurrFirstImg(currMiddleImgRef.current);\n    } else {\n      // Left side image click\n      currMiddleImgRef.current = currMiddleImgRef.current + 1 < imgList.length ? currMiddleImgRef.current + 1 : 0; // Conditions to handle cycle\n\n      setCurrFirstImg(currMiddleImgRef.current);\n    }\n  };\n\n  var gapBetween = props.name === 'team' ? 4.4 : 3.4;\n\n  var constructVisibleItemsProps = function constructVisibleItemsProps() {\n    var visibleItemsProps = {}; // To store config for items that are visibile in the carousel\n\n    visibleItemsProps.order = [];\n    var curr_center = currFirstImg; // Storing the Current Middle element in focus\n\n    var timesToIterate = 0; // To iterate through all visible number of images.\n\n    var zIndex = -elementsInRight; // We start from left to right and Zindex has to keep on increasing till middle then has to reduce.\n\n    var xTranslate = img_width; // To move the element with respect to x axis\n\n    var zTranslate = 0; // To reduce image size for images apart from center\n\n    var opacity = 1; // ARALIKLAR BURADA = 4\n\n    var division = img_width * (gapBetween / elementsInLeft); // Specifies the length that next image has to move away from with respect to current image (1.6 times the current image)\n\n    var opacityDivider = 1 / elementsInRight; // minimum opacity should be 0.3 (1-0.7)\n\n    var rightEltCount = elementsInRight;\n    var leftEltCount = elementsInLeft; // including middle element\n\n    var curr_center_copy = curr_center;\n\n    while (timesToIterate < visibleImages) {\n      var styles = {};\n      var currImgIndex = void 0;\n      var currImgIndexOnRight = true; // Tells if in this iteration the currently iterated image lies left to the middle image or not\n      // To set properties for elements in right side\n\n      if (timesToIterate < elementsInRight) {\n        var nextIndex = curr_center - rightEltCount;\n        currImgIndex = nextIndex > -1 ? nextIndex : imgList.length - Math.abs(nextIndex); // Gives the rightmost elemnt in first iteration and then the subsequent elements down the iteration\n\n        opacity = 1 - opacityDivider * rightEltCount; // To assign lowest opacity to last element and increaing it till we come to middle\n\n        zTranslate = -division * rightEltCount; // To increase the size of the images subsequently from last to middle\n\n        xTranslate = img_width - division * rightEltCount; // X coordinate position\n\n        rightEltCount--;\n      } else {\n        // To set properties for elements in center and to left of it. All props behaves similar to right\n        currImgIndexOnRight = false;\n        currImgIndex = curr_center_copy;\n\n        if (curr_center_copy + 1 >= imgList.length) {\n          // to maintain cyclic carousel\n          curr_center_copy = 0;\n        } else {\n          curr_center_copy++;\n        }\n\n        opacity = 1 - opacityDivider * Math.abs(leftEltCount - (timesToIterate + 1));\n        zTranslate = -division * Math.abs(leftEltCount - (timesToIterate + 1));\n        xTranslate = img_width + division * Math.abs(leftEltCount - (timesToIterate + 1));\n      } // Assigning above calculated values to 'styles' object\n\n\n      styles.transform = 'translateX(' + xTranslate + 'px) translateZ(' + zTranslate + 'px)';\n      styles.opacity = opacity;\n      styles.zIndex = currImgIndexOnRight ? zIndex++ : zIndex--; // To reduce zIndex while going through left elements\n\n      visibleItemsProps.order.push(currImgIndex); // Push the current image number in the orders array\n\n      visibleItemsProps[currImgIndex] = {\n        styles: styles\n      }; // pushing all previously created styles\n\n      timesToIterate++;\n    }\n\n    durationRef.current = actualFirst === '' ? duration : duration / imgDifference.current; // duration will be user given if he clicks next image or\n    // we divide the duration by number of images skipped\n\n    setVisibleItemsProps(visibleItemsProps); // setting state for visible items\n  };\n\n  React.useEffect(function () {\n    clearInterval(intervalRef.current);\n\n    if (actualFirst !== '') {\n      intervalRef.current = setInterval(function () {\n        if (actualFirst !== '' && actualFirst !== currMiddleImgRef.current) {\n          // If the currentimage in middle is not actually clicked image then gotoNext image\n          cycleToNextImage(actualFirst);\n        } else if (actualFirst !== '' && actualFirst === currMiddleImgRef.current) {\n          setActualFirst('');\n          imgDifference.current = 1;\n          clearInterval(intervalRef.current); // If actual clicked and middle image are same we are all set to clear intervals, as they are unnecessary now\n        }\n      }, durationRef.current - 100); // Introduced an advance of 100ms to begin bringing nextimage\n      // to middle before the previous one settles down else it looks jerky\n    }\n  }, [actualFirst]);\n  React.useEffect(function () {\n    constructVisibleItemsProps(); // This constructs all css properties to the elements in visibility\n\n    currMiddleImgRef.current = currFirstImg; // Need to set it here as well so while accessing inside interval it will have the latest value\n  }, [currFirstImg]);\n  React.useEffect(function () {\n    if (autoNext) {\n      setInterval(function () {\n        var nextImg = currMiddleImgRef.current + 1 < imgList.length ? currMiddleImgRef.current + 1 : 0;\n        setCurrFirstImg(nextImg);\n      }, timeForNext);\n    }\n  }, []);\n\n  var _React$useState7 = React.useState(0),\n      _React$useState8 = _slicedToArray(_React$useState7, 2),\n      middleImageKey = _React$useState8[0],\n      setMiddleImageKey = _React$useState8[1];\n\n  var loadCarousel = function loadCarousel() {\n    return __jsx(\"div\", {\n      className: \"carousel__3D carousel__3D--\".concat(props.name)\n    }, __jsx(\"ul\", {\n      ref: wrapper,\n      className: \"carousel__wrapper\",\n      style: {\n        height: parentHeight + 'px',\n        width: parentWidth + 'px',\n        padding: parentPad + 'px',\n        perspective: '500px'\n      }\n    }, imgList.map(function (image, index) {\n      var displayNone = visibleItemsProps.order.indexOf(index) === -1; // To not to show images that are out of visibility scope\n\n      var styles = visibleItemsProps[index] ? visibleItemsProps[index].styles : {};\n      return __jsx(\"li\", {\n        key: index,\n        className: 'carousel__item ' + (displayNone ? 'd-none' : ''),\n        style: _objectSpread({}, styles, {\n          position: 'absolute',\n          transition: \"all \".concat(durationRef.current, \"ms ease \")\n        }),\n        onClick: function onClick(e) {\n          changeCenter({\n            e: e,\n            index: index\n          });\n          setMiddleImageKey(index);\n        }\n      }, __jsx(\"img\", {\n        src: image,\n        alt: 'img',\n        width: img_width,\n        height: img_height\n      }));\n    })), __jsx(\"div\", {\n      className: \"carousel__infos carousel__infos--\".concat(props.name)\n    }, props.name === \"team\" ? props.data.map(function (item, key) {\n      return key === middleImageKey && __jsx(\"div\", {\n        key: key,\n        className: \"infos__item\"\n      }, __jsx(\"h3\", null, item.mitarbeiter_name), __jsx(\"h4\", null, item.mitarbeiter_titel), __jsx(Obfuscate, {\n        email: item.mitarbeiter_email\n      }), __jsx(Obfuscate, {\n        tel: item.mitarbeiter_telefon\n      }));\n    }) : props.data.map(function (item, key) {\n      return key === middleImageKey && __jsx(\"div\", {\n        key: key,\n        className: \"infos__item infos__item--downloads\"\n      }, __jsx(\"h4\", null, item.name), __jsx(\"a\", {\n        href: item.link,\n        target: \"_blank\",\n        className: \"singleloc__button\"\n      }, __jsx(Icon, {\n        type: \"factsheet\",\n        name: \"DOWNLOAD\"\n      })));\n    })), props.name === \"downloads\" && __jsx(\"div\", {\n      className: \"download__section--factsheet\"\n    }, __jsx(\"h2\", null, \"Factsheets\"), parse(props.content.Inhalt)));\n  };\n\n  return __jsx(React.Fragment, null, loadCarousel());\n}","map":null,"metadata":{},"sourceType":"module"}